using System;
using Core.Save;
using Core.Utils;
using EasyButtons;
using Newtonsoft.Json;
using UI.SceneTransition;
using UnityEngine;


[JsonObject(MemberSerialization.OptIn)]
public class GameManager : MonoBehaviour, ISaveHandler
{
    [Tooltip("Whether to spawn enemies or not. Set to false for testing")]
    public bool SpawnEnemies = true;

    [Tooltip("Whether to load the game save or not. Set to false for testing")]
    public bool LoadGameSave = true;

    [Tooltip("Reference to the scene transition controller")]
    public SceneTransitionController sceneTrans;
    
    private GameControls inputs; // The autogenerated reference to the input actions

    /// <summary>
    /// Static reference to the GameManager instance. This is set in Awake.
    /// </summary>
    public static GameManager Instance { get; private set; }

    /// <summary>
    /// Static reference to the input actions.
    /// </summary>
    public static GameControls Controls => Instance.inputs;

    /// <summary>
    /// The current area index. This is used to determine which area to load next.
    /// </summary>
    [JsonProperty]
    public static int CurrentAreaIndex { get; private set; } = 0;

    /// <summary>
    /// The amount of times the player has died.
    /// </summary>
    [JsonProperty]
    public int PlayerDeaths { get; private set; }  = 0;

    /// <summary>
    /// Whether the game is paused or not. This is a volatile value, meaning you can subscribe to it to get notified when it changes.
    /// </summary>
    public VolatileValue<bool> GamePaused = new();
    /// <summary>
    /// Event that is invoked when the level is to be generated.s
    /// </summary>
    public event Action GenerateLevelEvent;
    
    [Tooltip("Whether this GameManager is in a level scene or not. If true, level specific events such as GamePaused.Changed will be disabled.")]
    public bool isLevelScene = true;
    /// <summary>
    /// The name of the current save. This is used to determine which save to load.
    /// </summary>
    public static string CurrentSaveName { get; private set; } = "DefaultSave";
    
    void Awake()
    {
        Time.timeScale = 1; // Make sure time scale is set to 1 when starting
        // Create a new GameControls instance if it doesn't exist
        if (inputs == null)
        {
            inputs = new GameControls(); 
        }

        // Enable all input actions
        inputs.Enable();

        if (Instance != null)
        {
            Debug.LogError("Warning: multiple instances of GameManager found! The static instance will be changed to this one!!!! This is probably not what you want!");
        }
        Instance = this;
        
        // No need to register pause event handlers if not in level
        if (isLevelScene)
        {
            inputs.Menus.Pause.performed += (ctx) => { GamePaused.value = !GamePaused.value; };
            GamePaused.Changed += UpdateTimeScale;
            GameSaveManager.AddSaveHandler("game", this);
        }
        
    }
    
    private void Start()
    {
        // Load the game save if enabled
        if (LoadGameSave)
        {
            GameSaveManager.LoadSave(CurrentSaveName);
        }
        // Generate the level if in a level scene
        if (isLevelScene)
        {
            GenerateLevelEvent?.Invoke();
        }
        // Fade out scene transition if it exists
        sceneTrans?.FadeOut();
    }
    

    public void UpdateTimeScale()
    {
        // Set time scale to 0 if game is paused, otherwise set it to 1
        Time.timeScale = (GamePaused.value) ? 0 : 1;
    }
    
    /// <summary>
    /// Loads the game scene from the main menu
    /// </summary>
    /// <param name="saveName"></param>
    public void LoadGame(string saveName = "DefaultSave")
    {
        CurrentSaveName = saveName;
        sceneTrans?.TransitionToScene("GameLevel");
    }

    /// <summary>
    /// Clears the current save
    /// </summary>
    [Button]
    public void ClearSave()
    {
        GameSaveManager.DeleteSave(CurrentSaveName);
    }

    /// <summary>
    /// Loads the current save
    /// </summary>
    /// <param name="saveName"></param>
    [Button]
    public void LoadSave()
    {
        GameSaveManager.LoadSave(CurrentSaveName);
    }

    /// <summary>
    /// Writes to the current save
    /// </summary>
    [Button]
    public void WriteSave()
    {
        if (!isLevelScene) return; // No need to write to save if not in level as WriteSave is intended for level progress / saves
        GameSaveManager.WriteSave(CurrentSaveName);
    }

    /// <summary>
    /// Opens the saves location in the file explorer
    /// </summary>
    [Button]
    public void OpenSavesLocation()
    {
        Application.OpenURL($"file://{GameSaveManager.SavesLocation}");
    }
    

    /// <summary>
    /// Increments the current area index and loads the next area.
    /// </summary>
    public void LoadNextArea()
    {
        CurrentAreaIndex++;
        sceneTrans.TransitionToScene("GameLevel");
    }
    
    /// <summary>
    /// Decrements the current area index and loads the next area if possible.
    /// </summary>
    public void LoadPrevArea()
    {
        CurrentAreaIndex = Mathf.Max(0, CurrentAreaIndex - 1);
        sceneTrans.TransitionToScene("GameLevel");
    }

    /// <summary>
    /// Respawns the player. (Which sends them back to the first area)
    /// </summary>
    /// <param name="notDeath">When true, respawns the player without adding to the death counter.</param>
    public void RespawnPlayer(bool notDeath = false)
    {
        CurrentAreaIndex = 0;
        if (!notDeath) PlayerDeaths += 1;
        sceneTrans.TransitionToScene("GameLevel");
    }

    /// <summary>
    /// Quits to the main menu.
    /// </summary>
    public void QuitToMainMenu()
    {
        WriteSave();
        sceneTrans.TransitionToScene("MainMenu");
    }

    /// <summary>
    /// Quits the game.
    /// </summary>
    public void QuitGame()
    {
        WriteSave();
        Application.Quit();
    }

    /// <summary>
    /// When this instance is destroyed, write to the save and clear all save handlers.
    /// </summary>
    private void OnDestroy()
    {
        WriteSave();
        GameSaveManager.ClearSaveHandlers();
    }

    /// <summary>
    /// Disables the input actions when this instance is disabled.
    /// </summary>
    private void OnDisable()
    {
        inputs.Disable();
    }
}